# EntiDB Release Blockers (01 Jan 2025 - 2)

  This memo records confirmed release blockers from a deep repo review. Each issue is grounded in code evidence and mapped to EntiDB
  invariants.

  ---

  ## RB-01 - WASM commits acknowledge success without durable persistence

  **Evidence**

  - WASM `Database.put`, `Database.delete`, and `Transaction.commit` call core transactions but do not await persistence; durability relies on
  manual `save()`.
    - `web/entidb_wasm/src/database.rs:253`
    - `web/entidb_wasm/src/database.rs:296`
    - `web/entidb_wasm/src/database.rs:989`
  - `PersistentBackend.flush/sync` are synchronous no-ops for real persistence.
    - `web/entidb_wasm/src/backend/persistent.rs:141`

  **Why this is a release blocker**

  Commit acknowledgment must imply durability (AC-04, docs/transactions.md). As-is, a crash or tab termination after a successful commit loses
  data.

  **Single robust solution**

  Make commit paths async and await `save()` (or equivalent durable persistence) before returning success. If durability must be weaker on web,
  make that explicit in the API contract.

  ---

  ## RB-02 - WASM persistence bypasses manifest/lock and loses metadata across restarts

  **Evidence**

  - WASM uses `open_with_backends` (test-only path) which skips MANIFEST/LOCK and initializes a new in-memory manifest.
    - `web/entidb_wasm/src/database.rs:177`
    - `crates/entidb_core/src/database.rs:324`
    - `crates/entidb_core/src/database.rs:439`

  **Why this is a release blocker**

  Collection name→ID mapping and index definitions are not persisted. After restart, existing segment data can become unreachable because
  collection IDs are re-generated. This violates binding parity and the file format contract (docs/file_format.md).

  **Single robust solution**

  Provide a web-compatible open path that persists the MANIFEST and enforces single-writer semantics (or equivalent), then have WASM use it. If
  web storage can’t support the full layout, define and version a web-specific layout that still persists manifest metadata.

  ---

  ## RB-03 - IndexedDb save path corrupts data (append-only snapshots)

  **Evidence**

  - `PersistentBackend::save` appends the full snapshot when using IndexedDb, rather than overwriting existing data.
    - `web/entidb_wasm/src/backend/persistent.rs:166`

  **Why this is a release blocker**

  Appending the full snapshot on each save corrupts the file layout and breaks offsets, resulting in inconsistent reads and eventual data loss.

  **Single robust solution**

  Make the IndexedDb backend overwrite the stored bytes (or truncate then write) when saving snapshots, matching the semantics of
  `OpfsBackend::write_all`.

  ---

  ## RB-04 - IndexedDb backend is a localStorage stub (not a byte store, not durable)

  **Evidence**

  - `IndexedDbBackend` is implemented using localStorage and base64 encoding, not IndexedDB.
    - `web/entidb_wasm/src/backend/indexeddb.rs:1`

  **Why this is a release blocker**

  LocalStorage is not a durable byte store and violates the web durability criteria (AC-17, AC-18). It also risks data truncation and encoding
  bugs.

  **Single robust solution**

  Replace the stub with a real IndexedDB-backed byte store or disable the fallback for production builds.

  ---

  ## RB-05 - Implicit collection creation and silent fallback violate “no magic”

  **Evidence**

  - `Database::collection` auto-creates and, on manifest persistence failure, silently creates an in-memory-only collection ID.
    - `crates/entidb_core/src/database.rs:875`
  - WASM uses this API directly.
    - `web/entidb_wasm/src/database.rs:228`

  **Why this is a release blocker**

  Implicit behavior and silent fallback violate the explicit, predictable behavior rule (docs/invariants.md). It can lead to data being written
  under non-durable collection IDs without the caller knowing.

  **Single robust solution**

  Remove or hard-error on fallback in production paths and require explicit `create_collection()` with error handling. Update WASM to use the
  explicit API.

  ---

  ## RB-06 - Public APIs allow index-by-name queries (violates access-path rules)

  **Evidence**

  - Core and bindings expose index creation/lookup by user-provided names or fields (hash/btree/fts).
    - `crates/entidb_core/src/database.rs:1394`
    - `crates/entidb_core/src/database.rs:1584`
    - `crates/entidb_core/src/database.rs:1701`
    - `crates/entidb_ffi/src/database.rs:896`
    - `crates/entidb_ffi/src/database.rs:1283`
    - `bindings/dart/entidb_dart/lib/src/database.dart:822`
    - `bindings/python/entidb_py/src/lib.rs:661`
    - `web/entidb_wasm/src/database.rs:660`
    - `web/entidb_wasm/src/database.rs:792`

  **Why this is a release blocker**

  `docs/access_paths.md` requires indexes to be engine-selected; users must not reference indexes by name during queries. Exposing index-based
  lookup changes observable behavior and locks in index identities.

  **Single robust solution**

  Remove index-name lookup surfaces from all public APIs and expose only explicit scan APIs plus semantic field-based predicates that do not
  mention index identities, letting the engine choose access paths.

  ---

  ## Notes (Non-blockers but relevant)

  - I did not find non-test `panic!/unwrap()/expect()` in production Rust core/storage/FFI paths in this review pass. Remaining occurrences
  appear in tests/examples.

  ---

  ## Suggested Release Gate (Non-code)

  1. WASM durability: verify commit ack implies durable persistence (integration test).
  2. Web layout: MANIFEST/metadata persistence is validated across reloads.
  3. IndexedDb: real byte-store backend or fallback disabled for release.
  4. Index API: public surface matches `docs/access_paths.md`.