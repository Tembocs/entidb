**Findings (new vs past todos)**  
- **Manifest encoding silently truncates counts/lengths (corruption risk)** — `crates/entidb_core/src/manifest.rs:130`, `crates/entidb_core/src/manifest.rs:136`, `crates/entidb_core/src/manifest.rs:146`, `crates/entidb_core/src/manifest.rs:159`, `crates/entidb_core/src/manifest.rs:164`. The use of `unwrap_or(u32::MAX)` / `unwrap_or(u16::MAX)` clamps oversized counts and field lengths, producing a manifest that cannot be decoded deterministically and can desync collection/index metadata. This is not listed in any `docs/todo/*`.  
  **Robust solution:** Make manifest encoding fallible and reject oversize values explicitly (typed error) and/or enforce explicit limits at collection/index creation time (max collection name length, max field path length, max collections/indexes). Modern storage engines treat metadata serialization as strict-validation; never clamp.
  **Status: ✅ FIXED** — Changed `Manifest::encode()` to return `CoreResult<Vec<u8>>` and added explicit validation with typed errors for all size limits.

- **Segment record length can overflow and write malformed records** — `crates/entidb_core/src/segment/record.rs:116`. `record_len` is computed as `usize` and cast to `u32` without bounds checking; large payloads will overflow and corrupt segment files. Not present in `docs/todo/*`.  
  **Robust solution:** Introduce a hard maximum payload size for segments (e.g., `u32::MAX - HEADER_SIZE - CRC_SIZE`) and reject oversized writes with a typed error before encoding. Keep limits aligned with WAL limits to preserve invariants.
  **Status: ✅ FIXED** — Added `SegmentRecord::MAX_PAYLOAD_SIZE` constant and changed `encode()` to return `CoreResult<Vec<u8>>` with explicit validation.

- **WAL recovery can allocate unbounded buffers on corrupted lengths (OOM risk)** — `crates/entidb_core/src/wal/iterator.rs:157`, `crates/entidb_core/src/wal/iterator.rs:223`. The iterator resizes the buffer to `min_bytes.next_power_of_two()` based on a length field read from WAL, with no cap. A corrupted length in a large WAL can trigger huge allocations during recovery. This is not in past todos.  
  **Robust solution:** Enforce a strict maximum WAL record size (e.g., `WalRecord::MAX_PAYLOAD_SIZE`) and treat any record exceeding it as corruption. Cap buffer growth and fail fast with a typed WAL corruption error.
  **Status: ✅ FIXED** — Added `MAX_WAL_RECORD_SIZE` constant (256 MB) and validation before buffer allocation to prevent OOM attacks.

- **Segment streaming iterator can get stuck on a corrupt record** — `crates/entidb_core/src/segment/store.rs:1191`, `crates/entidb_core/src/segment/store.rs:1209`, `crates/entidb_core/src/segment/store.rs:1214`. If `SegmentRecord::decode` fails, the iterator returns an error without advancing the offset or marking exhaustion; callers that keep iterating can hit the same corruption repeatedly. Not listed in `docs/todo/*`.  
  **Robust solution:** Treat decode errors as fatal for that iterator: mark it exhausted after the first error and return a typed corruption error with segment ID/offset. This aligns with modern DB recovery semantics (fail fast on corruption rather than looping).
  **Status: ✅ FIXED** — Set `self.exhausted = true` on decode error and wrap error with segment ID/offset context.