# EntiDB Production-Readiness TODO (31 Dec 2025 — 2)

This document captures the highest-impact production readiness findings from a deep repo review, and the single best proposed fix for each (no alternative options listed).

Scope: Rust core + storage + FFI/bindings surface, focusing on crash safety, determinism, robustness, and security properties described in the normative docs.

## 1) Bindings/FFI open path bypasses the on-disk DB layout

**Finding**

- `entidb_ffi::entidb_open()` opens `wal.log` and `segments.dat` directly and calls `entidb_core::Database::open_with_backends(...)`.
- This bypasses the directory-based layout and lifecycle described in `docs/file_format.md` and implemented in `entidb_core`’s directory-open path (MANIFEST, LOCK, SEGMENTS/seg-*.dat, etc.).
- The result is that bindings can observe different durability/locking/metadata behavior than Rust (violates binding parity risk).

**Why it matters**

- File layout mismatches are a production foot-gun: operators and tooling (backup/inspect/verify) expect the canonical layout.
- Skipping MANIFEST/LOCK undermines single-writer guarantees and durable metadata (collections/index defs/checkpoint seq).
- Binding parity is a hard invariant: Rust/Dart/Python must have identical observable behavior.

**Best solution**

- Make the bindings open the database via the same directory-based open path as Rust core (the path that:
  - takes/holds `LOCK`,
  - loads/saves `MANIFEST` atomically,
  - uses the `WAL/` and `SEGMENTS/` layout).
- Treat `Database::open_with_backends(...)` as an advanced/testing-only hook, and document that it does not provide the full directory/manifest contract unless the caller supplies an equivalent manifest+locking strategy.

## 2) Persistent segment rotation can silently become in-memory

**Finding**

- `entidb_core::SegmentManager::new(backend, max_segment_size)` is a “single backend” constructor that sets `backend_factory` to create *in-memory* backends for any rotated segments.
- `Database::open_with_backends(...)` constructs segments via `SegmentManager::new(...)`.
- Therefore, a file-backed DB opened via `open_with_backends` can start durable, then rotate into non-durable segments once it seals/rotates.

**Why it matters**

- This is a durability cliff: the database can acknowledge commits while data ends up written to in-memory segments.
- It can be extremely hard to diagnose (only manifests when segment rotation occurs).

**Best solution**

- For persistent database opens, require a segment backend factory that creates per-segment file backends (use `SegmentManager::with_factory(...)` / `with_factory_and_existing(...)`).
- Alternatively (if the API must remain), make `SegmentManager::new(...)` disable rotation and return a typed error if sealing/rotation would be required.

## 3) WAL record encoding clamps oversized payloads instead of erroring

**Finding**

- `WalRecord::encode_payload()` encodes `after_bytes` length as `u32` and uses `unwrap_or(u32::MAX)` when conversion fails.
- This can emit a WAL record whose declared length does not match the actual payload when the entity exceeds 4GiB.

**Why it matters**

- This can create self-corrupting WAL records and turns an input-size problem into a recovery-time corruption error.
- Production engines should reject oversize values deterministically at the API boundary with a typed error.

**Best solution**

- Reject any `after_bytes.len() > u32::MAX` at write/commit time with a typed error (e.g., `InvalidArgument`/`InvalidFormat`-class error), and never write an inconsistent WAL envelope.

## 4) Index rebuild on open is not streaming (OOM risk)

**Finding**

- On open, indexes are rebuilt by calling `segments.scan_all()` and then `index_engine.rebuild_from_records(&all_records)`.
- This collects all segment records into a single in-memory vector.

**Why it matters**

- Large databases can exhaust memory during open/recovery, even though WAL recovery is otherwise designed for streaming.
- This is an availability risk (DB cannot open under load or after growth).

**Best solution**

- Rebuild indexes using a streaming segment iterator (record-by-record) rather than materializing all records.
- Keep indexes correctness-independent (they must never affect query correctness); rebuild should be restartable and bounded-memory.

## 5) WAL growth controls appear incomplete (`max_wal_size` not enforced)

**Finding**

- `Config` defines `max_wal_size`, but it is not referenced outside `config.rs` (no enforcement).
- `checkpoint_interval` is disabled by default.

**Why it matters**

- WAL can grow without bound in long-lived processes unless an explicit checkpoint policy is used.
- While WAL replay is streaming, disk pressure and long recovery times become operational risks.

**Best solution**

- Implement a single, explicit WAL growth policy:
  - When WAL size exceeds `max_wal_size`, trigger a checkpoint (or a safe WAL rotation + checkpoint marker scheme if rotation is preferred).
- Document the production default: checkpointing must be enabled for long-running workloads.

## “Go/No-Go” checklist for starting implementation

- [x] Bindings open the same on-disk layout and locking contract as Rust core.
- [x] File-backed databases never rotate into in-memory segment backends.
- [x] Oversize entity payloads are rejected before WAL write (typed error).
- [x] Index rebuild on open is streaming and bounded-memory.
- [x] WAL growth is bounded by an explicit enforced policy (`max_wal_size` + checkpointing).

---

## Implementation Summary (Completed)

All five findings have been addressed. Here's what was changed:

### Fix 1: FFI directory-based open

**File:** `crates/entidb_ffi/src/database.rs`

Changed `entidb_open()` to use `Database::open_with_config()` instead of `open_with_backends()`.
This ensures bindings (Dart, Python via FFI) use the same LOCK/MANIFEST/WAL/SEGMENTS layout as Rust core.

### Fix 2: Segment rotation now errors instead of silently degrading

**File:** `crates/entidb_core/src/segment/store.rs`

Modified `SegmentManager::new()` to return `CoreError::invalid_argument()` when segment rotation is attempted,
rather than silently falling back to in-memory backends. Databases using `open_with_backends()` with a
single segment file must set `max_segment_size = u64::MAX` to disable rotation (as WASM does).

### Fix 3: WAL rejects oversized payloads

**Files:** `crates/entidb_core/src/wal/record.rs`, `crates/entidb_core/src/wal/writer.rs`, `crates/entidb_core/src/error.rs`

- Added `MAX_PAYLOAD_SIZE` constant (`u32::MAX as usize`)
- Changed `WalRecord::encode_payload()` to return `CoreResult<Vec<u8>>`
- Added `InvalidArgument` error variant
- Validates payload size before encoding, returns typed error instead of clamping

### Fix 4: Streaming index rebuild

**Files:** `crates/entidb_core/src/segment/store.rs`, `crates/entidb_core/src/index/engine.rs`, `crates/entidb_core/src/database.rs`

- Added `SegmentRecordIterator` struct with streaming `Iterator` implementation
- Added `SegmentManager::iter_all()` returning streaming iterator
- Added `IndexEngine::rebuild_from_iterator()` for bounded-memory rebuild
- Updated `Database::open_with_config()` and `create_index_impl()` to use streaming

### Fix 5: `max_wal_size` enforcement via auto-checkpoint

**File:** `crates/entidb_core/src/database.rs`

- Added `maybe_auto_checkpoint()` helper that triggers checkpoint when WAL exceeds `max_wal_size`
- Added public `wal_size()` method
- Called `maybe_auto_checkpoint()` after both `commit()` and `commit_write()`

### Binding updates

- **Python (`bindings/python/entidb_py/src/lib.rs`):** Changed to use `Database::open_with_config()`,
  removed `entidb_storage` dependency
- **WASM (`web/entidb_wasm/src/database.rs`):** Set `max_segment_size = u64::MAX` to disable rotation
  (web storage cannot create multiple segment files)
- **Dart/Flutter:** Uses FFI which already calls the updated `entidb_open()`

### Tests

All 590 workspace tests pass. All Rust examples (todo, notes, expenses) run successfully.
