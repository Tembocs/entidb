# EntiDB Release Blockers (31 Dec 2025)

This memo records **confirmed release blockers** discovered during a deep read of core durability/txn/recovery code and the WASM persistence wrapper. Each issue includes exactly **one** recommended solution, chosen to be robust and aligned with modern database principles (crash consistency, explicit durability contracts, determinism, and correctness over performance).

## Scope and standard

Normative constraints used as the bar for “release blocker”:

- `docs/invariants.md` (global invariants: crash safety, determinism, commit-only visibility, binding parity, no hidden behavior)
- `docs/transactions.md` (snapshot isolation + WAL flush before commit ack)
- `docs/access_paths.md` (engine-controlled access paths; users must not reference indexes by name; index existence must not change results)
- `docs/file_format.md` (normative on-disk layout + compatibility rules)

Only issues with concrete evidence in the repository are included here.

---

## RB-01 — WASM persistence does not actually persist committed data

**Evidence**

- The WASM `PersistentBackend` explicitly states that `flush()` and `sync()` are synchronous stubs and **do NOT** persist to OPFS/IndexedDB; persistence requires async `save()`.
  - `web/entidb_wasm/src/backend/persistent.rs`
- The WASM `Database.save()` implementation calls `checkpoint()` and then clears the dirty flag, but it does not call `PersistentBackend::save()`.
  - `web/entidb_wasm/src/database.rs`

**Why this is a release blocker**

A database cannot claim durability if a successful commit can be acknowledged while the bytes remain only in memory. In web runtimes, abrupt tab termination is common; without a guaranteed persistence step on the commit path, crashes will lose committed data.

**Single robust solution**

Make the WASM binding’s **commit acknowledgement contingent on successful async persistence**:

- Redesign the WASM API so that any operation that commits (e.g., `put`, `delete`, `checkpoint`, transaction-like calls) is ultimately implemented as an **async function that awaits persistence**.
- Concretely: the WASM wrapper must retain handles to the WAL and segment `PersistentBackend`s and call `save().await` on them **after** a successful core commit (and treat any `save()` failure as a failed commit from the caller’s perspective).

This aligns with modern DB practice: “commit ack implies durable” (or the API must explicitly name a weaker durability mode, which EntiDB’s invariants do not allow).

---

## RB-02 — Production `unwrap()` panics in WASM persistence backend

**Evidence**

- `RwLock` access uses `read().unwrap()` / `write().unwrap()` in production code paths:
  - `web/entidb_wasm/src/backend/persistent.rs` (`save()`, `append()`, `truncate()`)

**Why this is a release blocker**

The project’s reliability guardrail forbids `panic!/unwrap()/expect()` in non-test paths (especially on storage/FFI surfaces). A panic in persistence code can:

- kill the runtime
- lose in-memory state
- break transactional atomicity for callers

**Single robust solution**

Replace all lock `unwrap()` calls in non-test code with **typed error propagation**:

- If the lock is poisoned or otherwise unavailable, return a `StorageResult`/`WasmResult` error containing enough context to diagnose the failure.
- Ensure callers in the WASM wrapper propagate this error to JS rather than panicking.

This is standard DB hardening: storage layers must fail explicitly and recoverably, not crash the process.

---

## RB-03 — Index API exposes index names and violates engine-controlled access paths

**Evidence**

- Core APIs accept `name: &str` / `index_name: &str` for index creation and lookups (hash/btree/fts):
  - `crates/entidb_core/src/database.rs` (create/lookup/drop methods)
- Normative policy forbids users referencing indexes by name and requires engine-controlled selection:
  - `docs/access_paths.md`

**Why this is a release blocker**

If the public API allows specifying index names, users can couple correctness and business logic to a particular index definition. That breaks the invariants:

- “Index existence MUST NOT change results (only performance).”
- “Users MUST NOT reference indexes by name during queries.”

This is not an aesthetics issue; it is a correctness and long-term compatibility issue.

**Single robust solution**

Remove index-name-based query/lookup surfaces and make access paths engine-selected:

- Keep index **declaration** in terms of schema/field path metadata (or internal IDs) but do not accept an index name at query time.
- Expose only two query primitives at the DB API level:
  1) explicit `scan()` APIs
  2) semantic typed helpers (e.g., “lookup by field path / key”) that do not mention index identities and allow the engine to choose the best available access path.

This matches modern DB principles: indexes are implementation details; users express intent, the engine chooses access paths.

---

## RB-04 — Index rebuild errors are ignored even though indexes are treated as authoritative

**Evidence**

- Index rebuild errors are explicitly treated as non-fatal via `let _ = rebuild_from_iterator(...)`:
  - `crates/entidb_core/src/database.rs`
- Index lookups route to the IndexEngine as an authoritative source for results:
  - `crates/entidb_core/src/database.rs` (lookup methods)

**Why this is a release blocker**

A silent index rebuild failure can produce **wrong query results** without any error surfaced to the user. In modern DB design, indexes are either:

- guaranteed correct (and rebuild failures are fatal), or
- treated as optional accelerators with correctness-preserving fallbacks

The current behavior risks “incorrect but successful” responses.

**Single robust solution**

Make index correctness fail-safe by introducing an explicit **index validity state** and enforcing it on use:

- If an index rebuild fails at open time (or after compaction), mark that index as **invalid** and ensure any lookup through that index path is rejected (hard error) until a successful rebuild occurs.

This is the robust option for correctness: it prevents silent wrong answers, and forces operational visibility of index corruption/rebuild issues.

---

## RB-05 — Compaction deletes the wrong segment files and ignores deletion failures

**Evidence**

- Compaction captures `sealed_ids` before compaction and receives `removed_ids` from `compact_sealed(...)`.
- The deletion step deletes `sealed_ids` (pre-compaction list), not `removed_ids`, and it discards errors (`let _ = ...`).
  - `crates/entidb_core/src/database.rs`

**Why this is a release blocker**

Deleting the wrong files risks **data loss** (deleting segments that are still needed) or **disk bloat** (failing to delete the right ones). Ignoring deletion failures risks accumulating stale segments and undermines operational predictability.

Compaction is a safety-critical path in database engines; file lifecycle must be exact and crash-safe.

**Single robust solution**

Adopt a crash-safe, exact file lifecycle protocol for compaction:

- Delete **exactly** the `removed_ids` returned by the compaction operation (not a pre-captured list).
- Treat deletion failures as **hard errors returned to the caller** (do not ignore).

This is the minimal robust fix to prevent accidental deletion of live segments and to surface I/O failures immediately.

---

## RB-06 — Normative file format specification does not match implementation

**Evidence**

- Normative spec states:
  - WAL files live under `WAL/` as `wal-000001.log`, `wal-000002.log`, etc.
  - `docs/file_format.md`
- Implementation uses a single `wal.log` at the DB root and documents that layout:
  - `crates/entidb_core/src/dir.rs` (constants and documentation)

**Why this is a release blocker**

A database’s file format is a contract. If the “normative” spec and implementation disagree at release time, you risk:

- breaking compatibility guarantees
- shipping bindings/tests that encode contradictory assumptions
- permanently locking in the wrong behavior because data already exists “in the wild”

**Single robust solution**

Freeze the format contract by making the documentation and implementation match exactly, with explicit versioning:

- Update the normative spec to reflect the actual single-file `wal.log` layout (or, if you decide the spec is correct, refactor implementation to match it), and bump/encode a **format version** so future readers can reject incompatible layouts deterministically.

The key modern principle is: storage format changes must be explicit, versioned, and test-vector-backed.

---

## Suggested release gate (non-code)

Before release, treat the following as mandatory sign-offs:

1. WASM: demonstrate “commit ack implies persistence” via an integration test or manual reproducible script.
2. Panics: repository-wide audit that non-test code paths contain no `panic!/unwrap()/expect()` in core/storage/FFI/bindings.
3. Index policy: public API surface matches `docs/access_paths.md` (no index-name query surfaces).
4. Compaction: segment deletion uses `removed_ids` and surfaces deletion failures.
5. Format contract: `docs/file_format.md` and `entidb_core` agree on layout and versioning.
